use ncurses::*;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;
use chrono::NaiveDateTime;

#[derive(Serialize, Deserialize, Clone)]
struct Config {
    btr_pool_dir: String,
    snapshots_dir: String,
    auto_cleanup: bool,
    confirm_actions: bool,
    show_timestamps: bool,
    theme: String,
}

impl Default for Config {
    fn default() -> Self {
        Config {
            btr_pool_dir: "/mnt/btr_pool".to_string(),
            snapshots_dir: "/mnt/btr_pool/btrbk_snapshots".to_string(),
            auto_cleanup: false,
            confirm_actions: true,
            show_timestamps: true,
            theme: "default".to_string(),
        }
    }
}

struct ConfigManager {
    config: Config,
    config_path: PathBuf,
}

impl ConfigManager {
    fn new() -> Self {
        let config_path = dirs::home_dir()
            .unwrap_or_else(|| PathBuf::from("/tmp"))
            .join(".config")
            .join("btrbk_restore")
            .join("config.json");
        
        let mut manager = ConfigManager {
            config: Config::default(),
            config_path,
        };
        
        manager.load();
        manager
    }
    
    fn load(&mut self) {
        if let Ok(content) = fs::read_to_string(&self.config_path) {
            if let Ok(saved_config) = serde_json::from_str::<Config>(&content) {
                // Merge saved config with defaults (in case new keys were added)
                self.config.btr_pool_dir = saved_config.btr_pool_dir;
                self.config.snapshots_dir = saved_config.snapshots_dir;
                self.config.auto_cleanup = saved_config.auto_cleanup;
                self.config.confirm_actions = saved_config.confirm_actions;
                self.config.show_timestamps = saved_config.show_timestamps;
                self.config.theme = saved_config.theme;
            }
        }
    }
    
    fn save(&self) -> bool {
        if let Some(parent) = self.config_path.parent() {
            let _ = fs::create_dir_all(parent);
        }
        
        match serde_json::to_string_pretty(&self.config) {
            Ok(json) => fs::write(&self.config_path, json).is_ok(),
            Err(_) => false,
        }
    }
    
    fn get(&self, key: &str) -> String {
        match key {
            "btr_pool_dir" => self.config.btr_pool_dir.clone(),
            "snapshots_dir" => self.config.snapshots_dir.clone(),
            "auto_cleanup" => self.config.auto_cleanup.to_string(),
            "confirm_actions" => self.config.confirm_actions.to_string(),
            "show_timestamps" => self.config.show_timestamps.to_string(),
            "theme" => self.config.theme.clone(),
            _ => String::new(),
        }
    }
    
    fn set(&mut self, key: &str, value: &str) -> bool {
        match key {
            "btr_pool_dir" => {
                self.config.btr_pool_dir = value.to_string();
                true
            }
            "snapshots_dir" => {
                self.config.snapshots_dir = value.to_string();
                true
            }
            "auto_cleanup" => {
                self.config.auto_cleanup = value.parse().unwrap_or(false);
                true
            }
            "confirm_actions" => {
                self.config.confirm_actions = value.parse().unwrap_or(true);
                true
            }
            "show_timestamps" => {
                self.config.show_timestamps = value.parse().unwrap_or(true);
                true
            }
            "theme" => {
                self.config.theme = value.to_string();
                true
            }
            _ => false,
        }
    }
}

struct SnapshotManager {
    config_manager: ConfigManager,
}

impl SnapshotManager {
    fn new(config_manager: ConfigManager) -> Self {
        SnapshotManager { config_manager }
    }
    
    fn get_snapshots(&self) -> (Vec<String>, Vec<String>, Vec<String>) {
        let snapshots_dir = self.config_manager.get("snapshots_dir");
        
        match fs::read_dir(&snapshots_dir) {
            Ok(entries) => {
                let folders: Vec<String> = entries
                    .filter_map(|entry| {
                        let entry = entry.ok()?;
                        if entry.path().is_dir() {
                            Some(entry.file_name().to_string_lossy().into_owned())
                        } else {
                            None
                        }
                    })
                    .collect();
                
                let mut root_snapshots: Vec<String> = folders
                    .iter()
                    .filter(|f| f.starts_with("@.") && !f.starts_with("@home.") && !f.starts_with("@games."))
                    .cloned()
                    .collect();
                
                let mut home_snapshots: Vec<String> = folders
                    .iter()
                    .filter(|f| f.starts_with("@home."))
                    .cloned()
                    .collect();
                
                let mut games_snapshots: Vec<String> = folders
                    .iter()
                    .filter(|f| f.starts_with("@games."))
                    .cloned()
                    .collect();
                
                // Sort by date (newest first)
                root_snapshots.sort_by(|a, b| b.cmp(a));
                home_snapshots.sort_by(|a, b| b.cmp(a));
                games_snapshots.sort_by(|a, b| b.cmp(a));
                
                (root_snapshots, home_snapshots, games_snapshots)
            }
            Err(_) => (Vec::new(), Vec::new(), Vec::new()),
        }
    }
    
    fn format_snapshot_name(&self, snapshot: &str) -> String {
        let show_timestamps = self.config_manager.get("show_timestamps")
            .parse()
            .unwrap_or(true);
        
        if !show_timestamps {
            return snapshot.to_string();
        }
        
        // Extract timestamp from snapshot name
        let timestamp_str = if snapshot.starts_with("@.") {
            &snapshot[2..]
        } else if snapshot.starts_with("@home.") {
            &snapshot[6..]
        } else if snapshot.starts_with("@games.") {
            &snapshot[7..]
        } else {
            return snapshot.to_string();
        };
        
        // Parse timestamp (format: YYYYMMDD_HHMMSS)
        if let Ok(dt) = NaiveDateTime::parse_from_str(timestamp_str, "%Y%m%d_%H%M%S") {
            format!("{} ({})", snapshot, dt.format("%Y-%m-%d %H:%M:%S"))
        } else {
            snapshot.to_string()
        }
    }
    
    fn restore_snapshot(&self, snapshot: &str, snapshot_type: &str) -> bool {
        let btr_pool_dir = self.config_manager.get("btr_pool_dir");
        let snapshots_dir = self.config_manager.get("snapshots_dir");
        
        let source_path = Path::new(&snapshots_dir).join(snapshot);
        
        let (current_subvol, broken_subvol, new_subvol) = match snapshot_type {
            "root" => (
                Path::new(&btr_pool_dir).join("@"),
                Path::new(&btr_pool_dir).join("@.BROKEN"),
                Path::new(&btr_pool_dir).join("@"),
            ),
            "home" => (
                Path::new(&btr_pool_dir).join("@home"),
                Path::new(&btr_pool_dir).join("@home.BROKEN"),
                Path::new(&btr_pool_dir).join("@home"),
            ),
            "games" => (
                Path::new(&btr_pool_dir).join("@games"),
                Path::new(&btr_pool_dir).join("@games.BROKEN"),
                Path::new(&btr_pool_dir).join("@games"),
            ),
            _ => return false,
        };
        
        // Move current subvolume to .BROKEN
        if !run_command(&["mv", &current_subvol.to_string_lossy(), &broken_subvol.to_string_lossy()]) {
            return false;
        }
        
        // Create new snapshot
        if !run_command(&["btrfs", "subvolume", "snapshot", &source_path.to_string_lossy(), &new_subvol.to_string_lossy()]) {
            return false;
        }
        
        // Auto cleanup if enabled
        let auto_cleanup = self.config_manager.get("auto_cleanup")
            .parse()
            .unwrap_or(false);
        
        if auto_cleanup {
            run_command(&["btrfs", "subvolume", "delete", &broken_subvol.to_string_lossy()]);
        }
        
        true
    }
}

struct TUIApp {
    config_manager: ConfigManager,
    snapshot_manager: SnapshotManager,
    current_screen: String,
    selected_row: i32,
    selected_col: i32,
    status_message: String,
    status_timeout: i32,
}

impl TUIApp {
    fn new() -> Self {
        let config_manager = ConfigManager::new();
        let snapshot_manager = SnapshotManager::new(ConfigManager::new());
        
        TUIApp {
            config_manager,
            snapshot_manager,
            current_screen: "main".to_string(),
            selected_row: 0,
            selected_col: 0,
            status_message: String::new(),
            status_timeout: 0,
        }
    }
    
    fn init_colors(&self) {
        start_color();
        use_default_colors();
        
        // Color pairs matching Python version
        init_pair(1, COLOR_BLACK, COLOR_CYAN);    // Selected item
        init_pair(2, COLOR_RED, -1);              // Headers
        init_pair(3, COLOR_GREEN, -1);            // Success
        init_pair(4, COLOR_YELLOW, -1);           // Warning
        init_pair(5, COLOR_WHITE, COLOR_BLUE);    // Status bar
        init_pair(6, COLOR_CYAN, -1);             // Info
    }
    
    fn draw_header(&self) {
        let (_, width) = get_max_yx();
        
        // Title bar
        let title = "BTRBK Restore Tool v2.0";
        attron(COLOR_PAIR(5) | A_BOLD());
        let centered_title = format!("{:^width$}", title, width = width as usize);
        let display_title = if centered_title.len() >= width as usize {
            &centered_title[..width as usize - 1]
        } else {
            &centered_title
        };
        mvaddstr(0, 0, display_title);
        attroff(COLOR_PAIR(5) | A_BOLD());
        
        // Separator
        let separator = "-".repeat(std::cmp::min(width as usize - 1, 120));
        mvaddstr(1, 0, &separator);
    }
    
    fn draw_footer(&self) {
        let (height, width) = get_max_yx();
        
        // Key bindings
        let keys = vec![
            "Up/Down: Navigate",
            "Left/Right: Switch",
            "ENTER: Select",
            "S: Settings",
            "R: Refresh",
            "Q: Quit"
        ];
        let footer_text = keys.join(" | ");
        
        attron(COLOR_PAIR(5));
        let separator = "-".repeat(std::cmp::min(width as usize - 1, 120));
        mvaddstr(height - 2, 0, &separator);
        let display_footer = if footer_text.len() >= width as usize {
            &footer_text[..width as usize - 1]
        } else {
            &footer_text
        };
        mvaddstr(height - 1, 0, display_footer);
        attroff(COLOR_PAIR(5));
    }
    
    fn draw_status(&mut self) {
        if !self.status_message.is_empty() && self.status_timeout > 0 {
            let (height, width) = get_max_yx();
            attron(COLOR_PAIR(6));
            let display_status = if self.status_message.len() >= width as usize {
                &self.status_message[..width as usize - 1]
            } else {
                &self.status_message
            };
            mvaddstr(height - 3, 0, display_status);
            attroff(COLOR_PAIR(6));
            self.status_timeout -= 1;
        } else if self.status_timeout <= 0 {
            self.status_message.clear();
        }
    }
    
    fn set_status(&mut self, message: &str, timeout: i32) {
        self.status_message = message.to_string();
        self.status_timeout = timeout;
    }
    
    fn draw_main_screen(&self) {
        let (height, width) = get_max_yx();
        
        let (root_snapshots, home_snapshots, games_snapshots) = self.snapshot_manager.get_snapshots();
        
        if root_snapshots.is_empty() && home_snapshots.is_empty() && games_snapshots.is_empty() {
            attron(COLOR_PAIR(4) | A_BOLD());
            mvaddstr(height / 2, (width - 20) / 2, "No snapshots found!");
            attroff(COLOR_PAIR(4) | A_BOLD());
            return;
        }
        
        // Calculate column positions for three columns
        let col_width = (width - 8) / 3;
        let col1_x = 2;
        let col2_x = col1_x + col_width;
        let col3_x = col2_x + col_width;
        
        let start_y = 4;
        
        // Draw column headers
        attron(COLOR_PAIR(2) | A_BOLD());
        mvaddstr(start_y - 1, col1_x, &format!("ROOT ({})", root_snapshots.len()));
        mvaddstr(start_y - 1, col2_x, &format!("HOME ({})", home_snapshots.len()));
        mvaddstr(start_y - 1, col3_x, &format!("GAMES ({})", games_snapshots.len()));
        attroff(COLOR_PAIR(2) | A_BOLD());
        
        // Draw snapshots
        let max_display = height - 8; // Leave space for header/footer
        
        // Root snapshots (column 0)
        for (i, snapshot) in root_snapshots.iter().enumerate().take(max_display as usize) {
            if start_y + i as i32 >= height - 4 {
                break;
            }
            
            let y = start_y + i as i32;
            let display_name = self.snapshot_manager.format_snapshot_name(snapshot);
            let truncated = if display_name.len() > col_width as usize - 2 {
                &display_name[..col_width as usize - 2]
            } else {
                &display_name
            };
            
            if self.selected_col == 0 && i as i32 == self.selected_row {
                attron(COLOR_PAIR(1));
                mvaddstr(y, col1_x, truncated);
                attroff(COLOR_PAIR(1));
            } else {
                mvaddstr(y, col1_x, truncated);
            }
        }
        
        // Home snapshots (column 1)
        for (i, snapshot) in home_snapshots.iter().enumerate().take(max_display as usize) {
            if start_y + i as i32 >= height - 4 {
                break;
            }
            
            let y = start_y + i as i32;
            let display_name = self.snapshot_manager.format_snapshot_name(snapshot);
            let truncated = if display_name.len() > col_width as usize - 2 {
                &display_name[..col_width as usize - 2]
            } else {
                &display_name
            };
            
            if self.selected_col == 1 && i as i32 == self.selected_row {
                attron(COLOR_PAIR(1));
                mvaddstr(y, col2_x, truncated);
                attroff(COLOR_PAIR(1));
            } else {
                mvaddstr(y, col2_x, truncated);
            }
        }
        
        // Games snapshots (column 2)
        for (i, snapshot) in games_snapshots.iter().enumerate().take(max_display as usize) {
            if start_y + i as i32 >= height - 4 {
                break;
            }
            
            let y = start_y + i as i32;
            let display_name = self.snapshot_manager.format_snapshot_name(snapshot);
            let truncated = if display_name.len() > col_width as usize - 2 {
                &display_name[..col_width as usize - 2]
            } else {
                &display_name
            };
            
            if self.selected_col == 2 && i as i32 == self.selected_row {
                attron(COLOR_PAIR(1));
                mvaddstr(y, col3_x, truncated);
                attroff(COLOR_PAIR(1));
            } else {
                mvaddstr(y, col3_x, truncated);
            }
        }
        
    fn draw_settings_screen(&self) {
        let (height, width) = get_max_yx();
        
        let settings = vec![
            ("BTR Pool Directory", "btr_pool_dir"),
            ("Snapshots Directory", "snapshots_dir"),
            ("Auto Cleanup .BROKEN", "auto_cleanup"),
            ("Confirm Actions", "confirm_actions"),
            ("Show Timestamps", "show_timestamps"),
        ];
        
        let start_y = 4;
        
        attron(COLOR_PAIR(2) | A_BOLD());
        mvaddstr(start_y - 1, 4, "SETTINGS");
        attroff(COLOR_PAIR(2) | A_BOLD());
        
        for (i, (label, key)) in settings.iter().enumerate() {
            if start_y + (i * 2) as i32 >= height - 8 {
                break;
            }
            
            let y = start_y + (i * 2) as i32;
            let value = self.config_manager.get(key);
            
            if i as i32 == self.selected_row {
                attron(COLOR_PAIR(1));
            }
            
            let display_label = if label.len() + 1 >= width as usize - 6 {
                &format!("{}:", label)[..width as usize - 6]
            } else {
                &format!("{}:", label)
            };
            mvaddstr(y, 4, display_label);
            
            let value_str = match *key {
                "auto_cleanup" | "confirm_actions" | "show_timestamps" => {
                    if value.parse().unwrap_or(false) { "Yes" } else { "No" }
                }
                _ => &value,
            };
            
            let display_value = if value_str.len() >= width as usize - 8 {
                &value_str[..width as usize - 8]
            } else {
                value_str
            };
            mvaddstr(y + 1, 6, display_value);
            
            if i as i32 == self.selected_row {
                attroff(COLOR_PAIR(1));
            }
        }
        
        // Show config file path and status
        attron(A_DIM());
        let config_path = format!("Config: {}", self.config_manager.config_path.display());
        let config_exists = if self.config_manager.config_path.exists() { "EXISTS" } else { "NOT FOUND" };
        let config_info = format!("{} ({})", config_path, config_exists);
        let display_config_info = if config_info.len() >= width as usize - 6 {
            &config_info[..width as usize - 6]
        } else {
            &config_info
        };
        mvaddstr(height - 7, 4, display_config_info);
        mvaddstr(height - 6, 4, "ENTER: Edit | SPACE: Toggle | ESC: Back | S: Save");
        attroff(A_DIM());
    }
    
    fn confirm_dialog(&self, message: &str) -> bool {
        let confirm_actions = self.config_manager.get("confirm_actions")
            .parse()
            .unwrap_or(true);
        
        if !confirm_actions {
            return true;
        }
        
        let (height, width) = get_max_yx();
        
        // Create dialog window
        let dialog_width = std::cmp::min(message.len() + 10, width as usize - 4);
        let dialog_height = 5;
        let dialog_y = height / 2 - 2;
        let dialog_x = (width as usize - dialog_width) / 2;
        
        // Draw dialog box
        for i in 0..dialog_height {
            let spaces = " ".repeat(dialog_width);
            mvaddstr(dialog_y + i, dialog_x as i32, &spaces);
        }
        
        // Draw border (simple)
        let top_border = format!("+{}+", "-".repeat(dialog_width - 2));
        mvaddstr(dialog_y, dialog_x as i32, &top_border);
        mvaddstr(dialog_y + dialog_height - 1, dialog_x as i32, &top_border);
        for i in 1..dialog_height - 1 {
            mvaddstr(dialog_y + i, dialog_x as i32, "|");
            mvaddstr(dialog_y + i, (dialog_x + dialog_width - 1) as i32, "|");
        }
        
        let display_message = if message.len() >= dialog_width - 4 {
            &message[..dialog_width - 4]
        } else {
            message
        };
        mvaddstr(dialog_y + 1, (dialog_x + 2) as i32, display_message);
        mvaddstr(dialog_y + 3, (dialog_x + 2) as i32, "Y: Yes | N: No");
        refresh();
        
        loop {
            let key = getch();
            match key {
                121 | 89 => return true,  // 'y' or 'Y'
                110 | 78 | 27 => return false,  // 'n' or 'N' or ESC
                _ => continue,
            }
        }
    }
    
    fn handle_main_input(&mut self, key: i32) {
        let (root_snapshots, home_snapshots, games_snapshots) = self.snapshot_manager.get_snapshots();
        
        match key {
            KEY_UP => {
                if self.selected_row > 0 {
                    self.selected_row -= 1;
                }
            }
            KEY_DOWN => {
                let max_rows = match self.selected_col {
                    0 => root_snapshots.len() as i32,
                    1 => home_snapshots.len() as i32,
                    2 => games_snapshots.len() as i32,
                    _ => 0,
                };
                
                if self.selected_row < max_rows - 1 {
                    self.selected_row += 1;
                }
            }
            KEY_LEFT => {
                if self.selected_col > 0 {
                    self.selected_col -= 1;
                    // Adjust row if new column has fewer items
                    let max_rows = match self.selected_col {
                        0 => root_snapshots.len() as i32,
                        1 => home_snapshots.len() as i32,
                        _ => 0,
                    };
                    if self.selected_row >= max_rows && max_rows > 0 {
                        self.selected_row = max_rows - 1;
                    }
                }
            }
            KEY_RIGHT => {
                if self.selected_col < 2 {
                    self.selected_col += 1;
                    // Adjust row if new column has fewer items
                    let max_rows = match self.selected_col {
                        1 => home_snapshots.len() as i32,
                        2 => games_snapshots.len() as i32,
                        _ => 0,
                    };
                    if self.selected_row >= max_rows && max_rows > 0 {
                        self.selected_row = max_rows - 1;
                    }
                }
            }
            10 | 13 => {  // ENTER
                self.handle_snapshot_selection(&root_snapshots, &home_snapshots, &games_snapshots);
            }
            115 | 83 => {  // 's' or 'S'
                self.current_screen = "settings".to_string();
                self.selected_row = 0;
            }
            114 | 82 => {  // 'r' or 'R'
                self.set_status("Refreshed snapshot list", 50);
            }
            _ => {}
        }
    }
    
    fn handle_snapshot_selection(&mut self, root_snapshots: &[String], home_snapshots: &[String], games_snapshots: &[String]) {
        let (snapshot, snapshot_type) = match self.selected_col {
            0 if !root_snapshots.is_empty() && (self.selected_row as usize) < root_snapshots.len() => {
                (&root_snapshots[self.selected_row as usize], "root")
            }
            1 if !home_snapshots.is_empty() && (self.selected_row as usize) < home_snapshots.len() => {
                (&home_snapshots[self.selected_row as usize], "home")
            }
            2 if !games_snapshots.is_empty() && (self.selected_row as usize) < games_snapshots.len() => {
                (&games_snapshots[self.selected_row as usize], "games")
            }
            _ => return,
        };
        
        // Confirm restoration
        if !self.confirm_dialog(&format!("Restore {} snapshot?", snapshot_type)) {
            self.set_status("Restoration cancelled", 50);
            return;
        }
        
        // Perform restoration
        self.set_status("Restoring snapshot...", 100);
        refresh();
        
        if self.snapshot_manager.restore_snapshot(snapshot, snapshot_type) {
            self.set_status("Snapshot restored successfully!", 100);
            
            // Ask for reboot
            if self.confirm_dialog("Reboot system now?") {
                run_command(&["reboot"]);
            }
        } else {
            self.set_status("Failed to restore snapshot!", 100);
        }
    }
    
    fn handle_settings_input(&mut self, key: i32) {
        let settings_count = 5; // Number of settings
        
        match key {
            KEY_UP => {
                if self.selected_row > 0 {
                    self.selected_row -= 1;
                }
            }
            KEY_DOWN => {
                if self.selected_row < settings_count - 1 {
                    self.selected_row += 1;
                }
            }
            10 | 13 => {  // ENTER
                self.edit_setting();
            }
            32 => {  // SPACE
                self.toggle_setting();
            }
            115 | 83 => {  // 's' or 'S'
                if self.config_manager.save() {
                    self.set_status("Settings saved manually!", 50);
                } else {
                    self.set_status("Failed to save settings!", 50);
                }
            }
            27 => {  // ESC
                self.current_screen = "main".to_string();
                self.selected_row = 0;
            }
            _ => {}
        }
    }
    
    fn edit_setting(&mut self) {
        let settings_keys = vec!["btr_pool_dir", "snapshots_dir", "auto_cleanup", "confirm_actions", "show_timestamps"];
        
        if (self.selected_row as usize) < settings_keys.len() {
            let key = settings_keys[self.selected_row as usize];
            let current_value = self.config_manager.get(key);
            
            // For boolean values, just toggle
            if matches!(key, "auto_cleanup" | "confirm_actions" | "show_timestamps") {
                let new_value = !current_value.parse().unwrap_or(false);
                self.config_manager.set(key, &new_value.to_string());
                self.config_manager.save();
                self.set_status(&format!("Toggled {}", key), 50);
                return;
            }
            
            // For string values, show simple input
            let (height, width) = get_max_yx();
            
            // Clear area for input
            for i in 0..5 {
                let spaces = " ".repeat(width as usize - 8);
                mvaddstr(height / 2 - 2 + i, 4, &spaces);
            }
            
            mvaddstr(height / 2 - 1, 4, &format!("Edit {}: ", key));
            mvaddstr(height / 2, 4, &format!("Current: {}", current_value));
            mvaddstr(height / 2 + 1, 4, "New: ");
            mvaddstr(height / 2 + 3, 4, "Press ENTER to confirm, ESC to cancel");
            refresh();
            
            curs_set(CURSOR_VISIBILITY::CURSOR_VISIBLE);
            echo();
            
            let mut input = String::new();
            let mut ch = getch();
            
            while ch != 10 && ch != 13 && ch != 27 {  // ENTER or ESC
                if ch == KEY_BACKSPACE || ch == 127 || ch == 8 {
                    if !input.is_empty() {
                        input.pop();
                        let display_input = format!("{} ", input);
                        mvaddstr(height / 2 + 1, 9, &display_input);
                    }
                } else if ch >= 32 && ch < 127 {  // Printable characters
                    input.push(ch as u8 as char);
                    mvaddstr(height / 2 + 1, 9, &input);
                }
                refresh();
                ch = getch();
            }
            
            noecho();
            curs_set(CURSOR_VISIBILITY::CURSOR_INVISIBLE);
            
            if ch != 27 && !input.trim().is_empty() {  // Not ESC and not empty
                self.config_manager.set(key, input.trim());
                self.config_manager.save();
                self.set_status(&format!("Updated {}", key), 50);
            } else {
                self.set_status("Edit cancelled", 50);
            }
        }
    }
    
    fn toggle_setting(&mut self) {
        let settings_keys = vec!["btr_pool_dir", "snapshots_dir", "auto_cleanup", "confirm_actions", "show_timestamps"];
        
        if (self.selected_row as usize) < settings_keys.len() {
            let key = settings_keys[self.selected_row as usize];
            
            if matches!(key, "auto_cleanup" | "confirm_actions" | "show_timestamps") {
                let current_value = self.config_manager.get(key);
                let new_value = !current_value.parse().unwrap_or(false);
                self.config_manager.set(key, &new_value.to_string());
                self.config_manager.save();
                self.set_status(&format!("Toggled {}", key), 50);
            }
        }
    }
    
    fn run(&mut self) {
        curs_set(CURSOR_VISIBILITY::CURSOR_INVISIBLE);
        timeout(100); // Non-blocking input with timeout
        
        self.init_colors();
        
        loop {
            clear();
            
            // Draw UI components
            self.draw_header();
            
            match self.current_screen.as_str() {
                "main" => self.draw_main_screen(),
                "settings" => self.draw_settings_screen(),
                _ => {}
            }
            
            self.draw_status();
            self.draw_footer();
            
            refresh();
            
            // Handle input
            let key = getch();
            
            if key == -1 {
                // Timeout, continue loop
                continue;
            } else if key == 113 || key == 81 {  // 'q' or 'Q'
                break;
            } else {
                match self.current_screen.as_str() {
                    "main" => self.handle_main_input(key),
                    "settings" => self.handle_settings_input(key),
                    _ => {}
                }
            }
        }
    }
}

fn run_command(cmd: &[&str]) -> bool {
    Command::new(cmd[0])
        .args(&cmd[1..])
        .status()
        .map(|status| status.success())
        .unwrap_or(false)
}

fn get_max_yx() -> (i32, i32) {
    let mut max_y = 0;
    let mut max_x = 0;
    getmaxyx(stdscr(), &mut max_y, &mut max_x);
    (max_y, max_x)
}

fn main() {
    // Check for root privileges
    if unsafe { libc::geteuid() } != 0 {
        eprintln!("Error: This tool requires root privileges.");
        eprintln!("Please run with sudo.");
        std::process::exit(1);
    }
    
    // Initialize ncurses
    initscr();
    cbreak();
    noecho();
    keypad(stdscr(), true);
    
    // Create and run the TUI app
    let mut app = TUIApp::new();
    app.run();
    
    // Cleanup
    endwin();
}
